// Copyright 2025 Nevermined AG.
// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)
// Code is Apache-2.0 and docs are CC-BY-4.0
pragma solidity ^0.8.30;

import {IAsset} from './interfaces/IAsset.sol';

import {IFeeController} from './interfaces/IFeeController.sol';
import {IHook} from './interfaces/IHook.sol';
import {INVMConfig} from './interfaces/INVMConfig.sol';
import {AccessManagedUUPSUpgradeable} from './proxy/AccessManagedUUPSUpgradeable.sol';
import {IAccessManager} from '@openzeppelin/contracts/access/manager/IAccessManager.sol';
import {ERC165Checker} from '@openzeppelin/contracts/utils/introspection/ERC165Checker.sol';

/**
 * @title AssetsRegistry
 * @author Nevermined AG
 * @notice This contract manages the registration and lifecycle of digital assets in the Nevermined ecosystem.
 * @dev The contract implements an upgradable pattern using ERC-7201 namespaced storage
 *      and OpenZeppelin's AccessManagedUUPSUpgradeable for access control.
 *      Assets are identified by unique DIDs (Decentralized Identifiers) and can have
 *      multiple pricing plans associated with them.
 */
contract AssetsRegistry is IAsset, AccessManagedUUPSUpgradeable {
    // keccak256(abi.encode(uint256(keccak256("nevermined.assetsregistry.storage")) - 1)) & ~bytes32(uint256(0xff))
    bytes32 private constant ASSETS_REGISTRY_STORAGE_LOCATION =
        0x6c9566430157c5ec4491fdbbed7bf67f82d06a6dee70d9aaa3ede461d7d98900;

    /// @custom:storage-location erc7201:nevermined.assetsregistry.storage
    struct AssetsRegistryStorage {
        /// @notice Configuration contract that stores system-wide parameters
        INVMConfig nvmConfig;
        /// @notice Mapping from asset DIDs to their metadata and associated information
        mapping(bytes32 => DIDAsset) assets;
        /// @notice The mapping of the plans registered in the contract
        mapping(uint256 => Plan) plans;
        /// @notice Mapping of plan ID to array of hook contracts
        mapping(uint256 => IHook[]) planHooks;
    }

    /**
     * @notice Initializes the AssetsRegistry contract with a configuration address and access manager
     * @param _nvmConfigAddress Address of the NVMConfig contract managing system configuration
     * @param _authority Address of the AccessManager contract handling permissions
     * @dev This function replaces the constructor for upgradeable contracts
     */
    function initialize(INVMConfig _nvmConfigAddress, IAccessManager _authority) external initializer {
        _getAssetsRegistryStorage().nvmConfig = _nvmConfigAddress;
        __AccessManagedUUPSUpgradeable_init(address(_authority));
    }

    /**
     * @notice Retrieves an asset by its decentralized identifier (DID)
     * @param _did The unique identifier of the asset to retrieve
     * @return The DIDAsset structure containing the asset's metadata
     * @dev Returns an empty structure if the asset does not exist
     */
    function getAsset(bytes32 _did) external view returns (DIDAsset memory) {
        return _getAssetsRegistryStorage().assets[_did];
    }

    /**
     * @notice Checks if an asset exists by its decentralized identifier (DID)
     * @param _did The unique identifier of the asset to check
     * @return Boolean indicating whether the asset exists
     * @dev An asset exists if it has been registered and has a non-zero lastUpdated timestamp
     */
    function assetExists(bytes32 _did) external view returns (bool) {
        return _getAssetsRegistryStorage().assets[_did].lastUpdated != 0;
    }

    /**
     * @notice Generates a DID using as seed a bytes32 and the address of the DID creator
     * @param _didSeed refers to DID Seed used as base to generate the final DID
     * @param _creator address of the creator of the DID
     * @return bytes32 The new DID created
     * @dev The DID is deterministically generated by hashing the seed and creator address
     */
    function hashDID(bytes32 _didSeed, address _creator) public pure returns (bytes32) {
        return keccak256(abi.encode(_didSeed, _creator));
    }

    /**
     * @notice Registers a new asset with associated plans
     * @param _didSeed Seed used to generate the final DID
     * @param _url URL to the asset's metadata
     * @param _plans Array of plan IDs associated with the asset
     * @dev The DID is generated by hashing the seed and creator address
     * @dev Emits AssetRegistered event on successful registration
     * @dev Allows the registration of assets without any plan, with the intention of further addition
     * @dev Will revert if the DID already exists or any plan doesn't exist
     */
    function register(bytes32 _didSeed, string memory _url, uint256[] memory _plans) public virtual {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if (bytes(_url).length == 0) {
            revert InvalidURL(_url);
        }

        bytes32 did = hashDID(_didSeed, msg.sender);
        if ($.assets[did].owner != address(0x0)) {
            revert DIDAlreadyRegistered(did);
        }

        for (uint256 i = 0; i < _plans.length; i++) {
            if ($.plans[_plans[i]].lastUpdated == 0) {
                revert PlanNotFound(_plans[i]);
            }
        }
        $.assets[did] =
            DIDAsset({owner: msg.sender, creator: msg.sender, url: _url, lastUpdated: block.timestamp, plans: _plans});

        emit AssetRegistered(did, msg.sender);
    }

    /**
     * @notice Creates a new pricing plan with specified configuration
     * @param _priceConfig Configuration for the plan's pricing model
     * @param _creditsConfig Configuration for the credits granted by the plan
     * @param _hooks Array of hook contracts to be called during agreement creation
     * @param _nonce Optional nonce to ensure unique plan IDs when using identical configurations
     * @return planId The ID of the created plan
     * @dev The nonce allows creating multiple plans with the same parameters but different identifiers
     * @dev Will revert if the NFT address is invalid or Nevermined fees aren't properly included for fixed price plans
     */
    function _createPlan(
        PriceConfig memory _priceConfig,
        CreditsConfig memory _creditsConfig,
        IHook[] memory _hooks,
        uint256 _nonce
    ) internal returns (uint256) {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if (_creditsConfig.minAmount > _creditsConfig.maxAmount) {
            revert InvalidCreditsConfigAmounts(_creditsConfig.minAmount, _creditsConfig.maxAmount);
        }

        if (_priceConfig.amounts.length != _priceConfig.receivers.length) {
            revert PriceConfigInvalidAmountsOrReceivers();
        }

        uint256 planId = hashPlanId(_priceConfig, _creditsConfig, msg.sender, _nonce);
        if ($.plans[planId].lastUpdated != 0) {
            revert PlanAlreadyRegistered(planId);
        }

        if (
            _priceConfig.feeController != $.nvmConfig.getDefaultFeeController()
                && _priceConfig.feeController != IFeeController(address(0x0))
        ) {
            require(
                $.nvmConfig.isFeeControllerAllowed(_priceConfig.feeController, msg.sender),
                NotAllowedToSetFeeController(msg.sender, _priceConfig.feeController)
            );
        }

        if (!_isNFT1155Contract(_creditsConfig.nftAddress)) {
            revert InvalidNFTAddress(_creditsConfig.nftAddress);
        }

        // Create the plan first
        $.plans[planId] =
            Plan({owner: msg.sender, price: _priceConfig, credits: _creditsConfig, lastUpdated: block.timestamp});

        // If the price type is FIXED_PRICE, we need to check if the Nevermined fees are included in the payment distribution
        if (!areNeverminedFeesIncluded(planId)) {
            revert NeverminedFeesNotIncluded(_priceConfig.amounts, _priceConfig.receivers);
        }

        // Store hooks for this plan
        uint256 previousHook = 0;
        for (uint256 i = 0; i < _hooks.length; i++) {
            uint256 hookId = uint256(uint160(address(_hooks[i])));
            require(hookId > previousHook, HooksMustBeUnique());
            previousHook = hookId;

            $.planHooks[planId].push(_hooks[i]);
        }

        emit PlanRegistered(planId, msg.sender);
        return planId;
    }

    /**
     * @notice Creates a new pricing plan with specified configuration
     * @param _priceConfig Configuration for the plan's pricing model
     * @param _creditsConfig Configuration for the credits granted by the plan
     * @param _hooks Array of hook contracts to be called during agreement creation
     * @return planId The ID of the created plan
     * @dev Uses a default nonce of 0 for plan ID generation
     */
    function createPlanWithHooks(
        PriceConfig memory _priceConfig,
        CreditsConfig memory _creditsConfig,
        IHook[] calldata _hooks
    ) public returns (uint256) {
        IHook[] memory hooks = _hooks;
        return _createPlan(_priceConfig, _creditsConfig, hooks, 0);
    }

    /**
     * @notice Creates a new pricing plan with specified configuration
     * @param _priceConfig Configuration for the plan's pricing model
     * @param _creditsConfig Configuration for the credits granted by the plan
     * @param _hooks Array of hook contracts to be called during agreement creation
     * @param _nonce Optional nonce to ensure unique plan IDs
     * @return planId The ID of the created plan
     */
    function createPlanWithHooks(
        PriceConfig memory _priceConfig,
        CreditsConfig memory _creditsConfig,
        IHook[] calldata _hooks,
        uint256 _nonce
    ) public returns (uint256) {
        IHook[] memory hooks = _hooks;
        return _createPlan(_priceConfig, _creditsConfig, hooks, _nonce);
    }

    /**
     * @notice Creates a new pricing plan with specified configuration
     * @param _priceConfig Configuration for the plan's pricing model
     * @param _creditsConfig Configuration for the credits granted by the plan
     * @return planId The ID of the created plan
     * @dev Uses a default nonce of 0 and no hooks
     */
    function createPlan(PriceConfig memory _priceConfig, CreditsConfig memory _creditsConfig)
        public
        returns (uint256)
    {
        IHook[] memory emptyHooks = new IHook[](0);
        return _createPlan(_priceConfig, _creditsConfig, emptyHooks, 0);
    }

    /**
     * @notice Creates a new pricing plan with specified configuration and nonce
     * @param _priceConfig Configuration for the plan's pricing model
     * @param _creditsConfig Configuration for the credits granted by the plan
     * @param _nonce Optional nonce to ensure unique plan IDs
     * @return planId The ID of the created plan
     * @dev Uses no hooks
     */
    function createPlan(PriceConfig memory _priceConfig, CreditsConfig memory _creditsConfig, uint256 _nonce)
        public
        returns (uint256)
    {
        IHook[] memory emptyHooks = new IHook[](0);
        return _createPlan(_priceConfig, _creditsConfig, emptyHooks, _nonce);
    }

    /**
     * @notice Registers a new asset and creates an associated pricing plan in a single transaction
     * @param _didSeed Seed used to generate the final DID
     * @param _url URL to the asset's metadata
     * @param _priceConfig Configuration for the plan's pricing model
     * @param _creditsConfig Configuration for the credits granted by the plan
     * @dev If the plan already exists, it will be reused rather than recreated
     * @dev This is a convenience function that combines plan creation and asset registration
     */
    function registerAssetAndPlan(
        bytes32 _didSeed,
        string memory _url,
        PriceConfig memory _priceConfig,
        CreditsConfig memory _creditsConfig
    ) external {
        uint256 planId = hashPlanId(_priceConfig, _creditsConfig, msg.sender);
        if (!planExists(planId)) {
            IHook[] memory emptyHooks = new IHook[](0);
            _createPlan(_priceConfig, _creditsConfig, emptyHooks, 0);
        }

        uint256[] memory _assetPlans = new uint256[](1);
        _assetPlans[0] = planId;
        register(_didSeed, _url, _assetPlans);
    }

    /**
     * @notice Retrieves a plan by its unique identifier
     * @param _planId The unique identifier of the plan to retrieve
     * @return The Plan structure containing the plan's configuration
     * @dev Returns an empty structure if the plan does not exist
     */
    function getPlan(uint256 _planId) external view returns (Plan memory) {
        return _getAssetsRegistryStorage().plans[_planId];
    }

    /**
     * @notice Checks if a plan exists by its unique identifier
     * @param _planId The unique identifier of the plan to check
     * @return Boolean indicating whether the plan exists
     * @dev A plan exists if it has been registered and has a non-zero lastUpdated timestamp
     */
    function planExists(uint256 _planId) public view returns (bool) {
        return _getAssetsRegistryStorage().plans[_planId].lastUpdated != 0;
    }

    /**
     * @notice Internal function to check if an address is the owner of a plan
     * @param _planId The ID of the plan to check
     * @param _address The address to check
     * @return bool True if the address is the plan owner
     */
    function _isPlanOwner(uint256 _planId, address _address) internal view returns (bool) {
        return _getAssetsRegistryStorage().plans[_planId].owner == _address;
    }

    /**
     * @notice Given the plan attributes and the address of the plan creator, it computes a unique identifier for the plan
     * @param _priceConfig The price configuration of the plan
     * @param _creditsConfig The credits configuration of the plan
     * @param _creator The address of the user that created the plan
     * @param _nonce Optional nonce to ensure uniqueness of the plan ID
     * @return uint256 The unique identifier of the plan
     * @dev The ID is deterministically generated by hashing all plan parameters together
     */
    function hashPlanId(
        PriceConfig memory _priceConfig,
        CreditsConfig memory _creditsConfig,
        address _creator,
        uint256 _nonce
    ) public pure returns (uint256) {
        return uint256(keccak256(abi.encode(_priceConfig, _creditsConfig, _creator, _nonce)));
    }

    /**
     * @notice Given the plan attributes and the address of the plan creator, it computes a unique identifier for the plan
     * @param _priceConfig The price configuration of the plan
     * @param _creditsConfig The credits configuration of the plan
     * @param _creator The address of the user that created the plan
     * @return uint256 The unique identifier of the plan
     * @dev Convenience overload that uses a default nonce of 0
     */
    function hashPlanId(PriceConfig memory _priceConfig, CreditsConfig memory _creditsConfig, address _creator)
        public
        pure
        returns (uint256)
    {
        return hashPlanId(_priceConfig, _creditsConfig, _creator, 0);
    }

    /**
     * @notice Add a new plan to an asset. This can only be done by the asset owner.
     * @param _did The unique identifier of the asset
     * @param _planId The unique identifier of the plan to add
     * @dev If the plan is already associated with the asset, the function returns without making changes
     * @dev Emits PlanAddedToAsset event on successful addition
     */
    function addPlanToAsset(bytes32 _did, uint256 _planId) external {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.assets[_did].lastUpdated == 0) {
            revert AssetNotFound(_did);
        }

        if ($.assets[_did].owner != msg.sender) {
            revert NotAssetOwner(_did, msg.sender, $.assets[_did].owner);
        }

        if ($.plans[_planId].lastUpdated == 0) {
            revert PlanNotFound(_planId);
        }

        // Check if plan is already in the asset's plans array
        uint256[] memory currentPlans = $.assets[_did].plans;
        for (uint256 i = 0; i < currentPlans.length; i++) {
            if (currentPlans[i] == _planId) {
                // Plan is already in the list, nothing to do
                return;
            }
        }

        // Add plan to the asset's plans array
        $.assets[_did].plans.push(_planId);
        $.assets[_did].lastUpdated = block.timestamp;

        emit IAsset.PlanAddedToAsset(_did, _planId, msg.sender);
    }

    /**
     * @notice Remove a plan from an asset. This can only be done by the asset owner.
     * @param _did The unique identifier of the asset
     * @param _planId The unique identifier of the plan to remove
     * @dev Uses a gas-efficient swap-and-pop pattern for array removal
     * @dev Emits PlanRemovedFromAsset event on successful removal
     */
    function removePlanFromAsset(bytes32 _did, uint256 _planId) external {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.assets[_did].lastUpdated == 0) {
            revert AssetNotFound(_did);
        }

        if ($.assets[_did].owner != msg.sender) {
            revert IAsset.NotAssetOwner(_did, msg.sender, $.assets[_did].owner);
        }

        uint256[] storage plans = $.assets[_did].plans;
        bool found = false;
        uint256 indexToRemove;

        // Find the index of the plan to remove
        for (uint256 i = 0; i < plans.length; i++) {
            if (plans[i] == _planId) {
                found = true;
                indexToRemove = i;
                break;
            }
        }

        if (!found) {
            revert PlanNotInAsset(_did, _planId);
        }

        // Remove the plan by swapping with the last element and popping
        if (indexToRemove != plans.length - 1) {
            plans[indexToRemove] = plans[plans.length - 1];
        }
        plans.pop();

        // Update the lastUpdated timestamp
        $.assets[_did].lastUpdated = block.timestamp;

        emit IAsset.PlanRemovedFromAsset(_did, _planId, msg.sender);
    }

    /**
     * @notice Replace all plans for an asset with a new set of plans. This can only be done by the asset owner.
     * @param _did The unique identifier of the asset
     * @param _plans The new array of plan IDs to associate with the asset
     * @dev Validates that all new plans exist before replacing
     * @dev Emits AssetPlansReplaced event on successful replacement
     */
    function replacePlansForAsset(bytes32 _did, uint256[] memory _plans) external {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.assets[_did].lastUpdated == 0) {
            revert AssetNotFound(_did);
        }

        if ($.assets[_did].owner != msg.sender) {
            revert NotAssetOwner(_did, msg.sender, $.assets[_did].owner);
        }

        // Validate that all plans exist
        uint256 previousPlan = 0;
        for (uint256 i = 0; i < _plans.length; i++) {
            require(_plans[i] > previousPlan, PlansMustBeUnique());
            previousPlan = _plans[i];

            if ($.plans[_plans[i]].lastUpdated == 0) {
                revert PlanNotFound(_plans[i]);
            }
        }

        // Replace the plans
        $.assets[_did].plans = _plans;
        $.assets[_did].lastUpdated = block.timestamp;

        emit IAsset.AssetPlansReplaced(_did, msg.sender);
    }

    /**
     * @notice Transfers the ownership of an asset to a new owner
     * @param _did The identifier of the asset
     * @param _newOwner The address of the new owner
     * @dev Only the current owner can transfer ownership
     * @dev Emits AssetOwnershipTransferred event on successful transfer
     */
    function transferAssetOwnership(bytes32 _did, address _newOwner) external {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.assets[_did].lastUpdated == 0) {
            revert AssetNotFound(_did);
        }

        if ($.assets[_did].owner != msg.sender) {
            revert NotAssetOwner(_did, msg.sender, $.assets[_did].owner);
        }

        address previousOwner = $.assets[_did].owner;
        $.assets[_did].owner = _newOwner;
        $.assets[_did].lastUpdated = block.timestamp;

        emit AssetOwnershipTransferred(_did, previousOwner, _newOwner);
    }

    /**
     * @notice Transfers the ownership of a plan to a new owner
     * @param _planId The identifier of the plan
     * @param _newOwner The address of the new owner
     * @dev Only the current owner can transfer ownership
     * @dev Emits PlanOwnershipTransferred event on successful transfer
     */
    function transferPlanOwnership(uint256 _planId, address _newOwner) external {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.plans[_planId].lastUpdated == 0) {
            revert PlanNotFound(_planId);
        }

        if ($.plans[_planId].owner != msg.sender) {
            revert NotPlanOwner(_planId, msg.sender, $.plans[_planId].owner);
        }

        address previousOwner = $.plans[_planId].owner;
        $.plans[_planId].owner = _newOwner;
        $.plans[_planId].lastUpdated = block.timestamp;

        emit PlanOwnershipTransferred(_planId, previousOwner, _newOwner);
    }

    /**
     * @notice Checks if Nevermined fees are included in the payment distribution
     * @param _planId The ID of the plan to check
     * @return bool True if Nevermined fees are properly included
     */
    function areNeverminedFeesIncluded(uint256 _planId) public view returns (bool) {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();
        IAsset.Plan storage plan = $.plans[_planId];
        PriceConfig storage priceConfig = plan.price;
        address feeReceiver = $.nvmConfig.getFeeReceiver();

        if (feeReceiver == address(0)) return true;

        bool _feeReceiverIncluded = false;
        uint256 _receiverIndex = 0;
        uint256 totalAmount = 0;
        uint256 amountsLength = priceConfig.amounts.length;
        for (uint256 i; i < amountsLength; i++) {
            if (priceConfig.receivers[i] == feeReceiver) {
                require(!_feeReceiverIncluded, MultipleFeeReceiversIncluded());

                _feeReceiverIncluded = true;
                _receiverIndex = i;
            } else {
                unchecked {
                    totalAmount += priceConfig.amounts[i];
                }
            }
        }

        if (totalAmount == 0) return true;

        // Calculate expected fee amount using the appropriate fee controller
        IFeeController feeController = plan.price.feeController == IFeeController(address(0))
            ? $.nvmConfig.getDefaultFeeController()
            : plan.price.feeController;
        uint256 expectedFeeAmount = feeController.calculateFee(totalAmount, plan.price, plan.credits);

        if (expectedFeeAmount == 0) return true;
        if (!_feeReceiverIncluded) return false;

        // Return if fee calculation is correct
        return expectedFeeAmount == priceConfig.amounts[_receiverIndex];
    }

    /**
     * @notice Adds Nevermined fees to the payment distribution if not already included
     * @param priceConfig The price configuration of the plan
     * @param creditsConfig The credits configuration of the plan
     * @return amounts Updated array of payment amounts including fees
     * @return receivers Updated array of payment receivers including fee recipient
     */
    function addFeesToPaymentsDistribution(
        IAsset.PriceConfig calldata priceConfig,
        IAsset.CreditsConfig calldata creditsConfig
    ) external view returns (uint256[] memory amounts, address[] memory receivers) {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.nvmConfig.getFeeReceiver() == address(0)) return (priceConfig.amounts, priceConfig.receivers);

        uint256 totalAmount = 0;
        uint256 amountsLength = priceConfig.amounts.length;
        for (uint256 i; i < amountsLength; i++) {
            unchecked {
                totalAmount += priceConfig.amounts[i];
            }
        }
        if (totalAmount == 0) return (priceConfig.amounts, priceConfig.receivers);

        // Calculate fee amount using the appropriate fee controller
        uint256 feeAmount;
        {
            IFeeController feeController = priceConfig.feeController == IFeeController(address(0))
                ? $.nvmConfig.getDefaultFeeController()
                : priceConfig.feeController;
            feeAmount = feeController.calculateFee(totalAmount, priceConfig, creditsConfig);
        }
        if (feeAmount == 0) return (priceConfig.amounts, priceConfig.receivers);

        uint256[] memory amountsWithFees = new uint256[](amountsLength + 1);
        for (uint256 i; i < amountsLength; i++) {
            unchecked {
                amountsWithFees[i] = priceConfig.amounts[i];
            }
        }
        amountsWithFees[amountsLength] = feeAmount;

        address[] memory receiversWithFees = new address[](amountsLength + 1);
        for (uint256 i; i < amountsLength; i++) {
            receiversWithFees[i] = priceConfig.receivers[i];
        }
        receiversWithFees[amountsLength] = $.nvmConfig.getFeeReceiver();

        return (amountsWithFees, receiversWithFees);
    }

    /**
     * @notice Checks if an address is a valid ERC-1155 NFT contract
     * @param _nftAddress The address to check
     * @return bool True if the address contains code and implements ERC-1155
     * @dev Uses the ERC-165 interface detection standard to check for ERC-1155 support
     */
    function _isNFT1155Contract(address _nftAddress) internal view returns (bool) {
        return ERC165Checker.supportsInterface(_nftAddress, 0xd9b67a26);
    }

    /**
     * @notice Accesses the contract's namespaced storage slot using ERC-7201
     * @return $ Reference to the contract's storage struct
     * @dev Uses assembly to access the specific storage slot for this contract's data
     */
    function _getAssetsRegistryStorage() internal pure returns (AssetsRegistryStorage storage $) {
        assembly ("memory-safe") {
            $.slot := ASSETS_REGISTRY_STORAGE_LOCATION
        }
    }

    /**
     * @notice Gets the hooks associated with a plan
     * @param _planId The ID of the plan
     * @return Array of hook contracts
     */
    function getPlanHooks(uint256 _planId) external view returns (IHook[] memory) {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();
        return $.planHooks[_planId];
    }

    /**
     * @notice Sets the hooks for a plan
     * @param _planId The ID of the plan
     * @param _hooks Array of hook contracts
     * @dev Only callable by the plan owner or authorized roles
     */
    function setPlanHooks(uint256 _planId, IHook[] calldata _hooks) external {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        // Verify plan exists and caller has permission
        if (!planExists(_planId)) revert PlanNotFound(_planId);
        if (!_isPlanOwner(_planId, msg.sender)) revert NotPlanOwner(_planId, msg.sender, $.plans[_planId].owner);

        // Clear existing hooks
        delete $.planHooks[_planId];

        // Set new hooks
        for (uint256 i = 0; i < _hooks.length; i++) {
            $.planHooks[_planId].push(_hooks[i]);
        }
    }

    /**
     * @notice Sets a custom fee controller for a plan
     * @param _planId The ID of the plan
     * @param _feeControllerAddress Address of the fee controller contract
     * @dev Only callable by the plan owner
     */
    function setPlanFeeController(uint256 _planId, IFeeController _feeControllerAddress) external restricted {
        AssetsRegistryStorage storage $ = _getAssetsRegistryStorage();

        if ($.plans[_planId].lastUpdated == 0) {
            revert PlanNotFound(_planId);
        }

        $.plans[_planId].price.feeController = _feeControllerAddress;
        $.plans[_planId].lastUpdated = block.timestamp;

        emit PlanFeeControllerUpdated(_planId, address(_feeControllerAddress));
    }
}
